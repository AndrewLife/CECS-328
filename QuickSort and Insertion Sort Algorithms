import java.util.*;
public class Lab3InsertionQuickSort {
	private static int n;
	private static int max = 14001;
	private static double QuickSum = 0;
	private static double InsertionSum = 0;
	
	/**
	 * Receive a randomized array to be sorted using QuickSort Algorithm
	 * Call a helper QuickSort Method passing in the array, lower Bound(index 0), and upper Bound(index array length - 1)
	 * @param a		Random Array
	 */
	public static void QuickSort(int [] a){
		QuickSort(a, 0, a.length - 1);
	}
	
	/**
	 * Recursive Method
	 * Algorithm will take the array, lower bound, and upper bound
	 * Find the pivot using the median of three
	 * Using the pivot as a reference, this method will move all the values that are less than the pivot to the left side of the array and more all values that are larger to the right.
	 * Repeat process with left sub array (values less than pivot) and right sub array (values larger than pivot)
	 * @param a			array to be sorted
	 * @param low		lower bound of array
	 * @param high		higher bound of array
	 * @return	array	return sorted array
	 */
	public static void QuickSort(int [] a, int low, int high){
		
		int pivot = 0;
		int first = a[low];
		int middle = a[(high + low)/2];
		int last = a[high];
		int temp;
		
		//Find the pivot
		if(first > middle && first < last || first > last && first < middle){
			pivot = first;
			temp = last;
			a[high] = first;
			a[low] = temp;
		}
		else if(middle > first && middle < last || middle > last && middle < first){
			pivot = middle;
			temp = last;
			a[high] = middle;
			a[(high + low)/2] = temp;
		}
		else if(last > middle && last < first || last > first && last < middle){
			pivot = last;
		}

		//Set lower and upper bounds
		int lowBound = low;
		int highBound = high - 1;
		
		//move values less than the pivot to the left, more values larger than the pivot to the right
		while(lowBound < highBound){
			while(a[lowBound] < pivot && lowBound < highBound){
				lowBound ++;
			}
			while(a[highBound] > pivot && highBound > lowBound){
				highBound--;
			}
			if(lowBound != highBound){
				int temp1 = a[highBound];
				a[highBound] = a[lowBound];
				a[lowBound] = temp1;

			}
		}

		//Move pivot between the lower values and larger values
		int temp1 = a[lowBound];
		a[lowBound] = pivot;
		a[high] = temp1;

		//Repeat method with smaller values
		if(low < lowBound && (lowBound - low != 0) && (lowBound - low != 1)){
			QuickSort(a, low, lowBound);
		}
		
		//Repeat method with larger values
		if(highBound < high && (high - highBound != 1)){
			QuickSort(a, highBound, high);
		}

	}
	
	/**
	 * Beginning at the first index, algorithm will look through array for the smallest value
	 * Swap with first element
	 * move onto the next index, look for the next smallest value and swap
	 * repeat step 3 until algorithm reaches the last element
	 * @param a		randomized array
	 * @return 		sorted array
	 */
	public static void InsertionSort(int [] a){
		int lowest;
		for(int i = 0; i < a.length; i++){
			for(int j = i; j < a.length; j++){
				lowest = a[i];
				if(a[j] < lowest){
					int temp1 = a[j];
					a[j] = a[i];
					a[i] = temp1;
				}
			}
		}
	}
	
	public static void main(String[]args){
		
		//Ask user for number of elements in array
		System.out.println("Enter the nubmer of elements in your array: ");
		Scanner input = new Scanner(System.in);
		Random r = new Random();
		StopWatch watch = new StopWatch();
		n = input.nextInt();
		
		//Create randomized array
		int [] array = new int [n];
		
		for(int i = 0; i < array.length; i++){
			array[i] = r.nextInt(max) - 7000;
		}

		//Calls QuickSort Method
		for(int i = 0; i < 100; i++){
			array = new int [n];
			for(int j = 0; j < array.length; j++){
				array[j] = r.nextInt(max) - 7000;
			}
			watch.start();
			QuickSort(array);
			watch.stop();
			//Used to calculate the average run time of a QuickSort algorithm
			QuickSum += (int) watch.getElapsedTime();
			watch.reset();
		}
		
		//Calls Insertion Sort Method
		for(int i = 0; i < 100; i++){
			array = new int [n];
			for(int j = 0; j < array.length; j++){
				array[j] = r.nextInt(max) - 7000;
			}
			
			watch.start();
			InsertionSort(array);
			watch.stop();
			//Used to calculate the average run time of a Insertion Sort algorithm
			InsertionSum += (int) watch.getElapsedTime();
			watch.reset();
		}
		
	    double QuickAverage = QuickSum/100;
		double InsertionAverage = InsertionSum/100;
		
		System.out.println();
		System.out.println("Array size of " + n + " and 100 repetitions");
		System.out.println("The average run time in nanoseconds for a QuickSort Algorithm is :" + QuickAverage);
		System.out.println("The average run time in nanoseconds for a Insertion Sort Algorithm is :" + InsertionAverage);
		
		//Calculate the run time for one line of instruction
		double insertionInstrPerNano = InsertionAverage /Math.pow(200, 2);
		
		//Converting to Seconds (1 second = 10^(-9) nanoseconds
		double insertionInstrPerSec = insertionInstrPerNano / 1000000000;
		
		//Calculating the max number of inputs for an insertion sort for a total run time of one second
		int numberOfInputInSec = (int) (1/insertionInstrPerSec);
		
		System.out.println();
		System.out.println("The max number of lines for an insertion sort in one second is: " + numberOfInputInSec);
		
	}
}
